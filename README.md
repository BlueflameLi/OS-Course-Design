# OS-Course-Design
 操作系统课程设计

##  实验一

- 内核修改时有自己标签，用 dmesg 验证
  - Linux 内核标签（系统启动显示一次）
  - 显示当前系统名称和版本的系统调用（内核、用户都有显示）
  - 修改 nice 和 prio 值的系统调用功能（内核、用户都有显示）
  - 改变主机名称为自定义字符串的系统调用（内核、用户都有显示）

## 实验二

- 模块一，用 dmesg 验证
  - 设计一个模块，要求列出系统中所有内核线程的程序名、PID 、进程状态、进程优先级、父进程的 PID
  - 输出按列对齐
- 模块二，用 dmesg 验证
  - 设计一个带参数的模块,其参数为某个进程的 PID 号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID 号及进程状态
  - 输出树结构，类似 pstree 的输出

## 实验三

- 实现一个模拟的shell

  - 编写三个不同的程序 cmd1.c 、cmd2.c 及 cmd3.c ，每个程序的功能自定，分别编译成可执行文件 cmd1 、cmd2 及 cmd3 。然后再编写一个程序，模拟 shell 程序的功能：能根据用输入的字符串(表示相应的命令名)，为相应的命令创建子进程并让它去执行相应的程序，而父进程则等待子进程结束，然后再等待接收下一条命令。如果接收到的命令为 exit ，则父进程结束，退出模拟 shell 如果接收到的命令是无效命令，则显示 “Command not found” ，继续等待输入下一条命令。此外，还要实现 **find**、**grep **命令，并给结果显示

  -  由父进程创建一个管道，然后再创建三个子进程，并由这三个子进程利用管道与父进程之间进行通信：子进程发送信息，父进程等三个子进程全部发完消息后再接收信息。通信的具体内容可根据自己的需要随意设计，要求能试验阻塞型读写过程中的各种情况，测试管道的默认大小，并且要求利用 Posix 信号量机制实现进程间对管道的互斥访问。运行程序，观察各种情况下，进程实际读写的字节数以及进程阻塞唤醒的情况。此外，还要实现有名管道通信（独立进程）。

  - 编写程序创建三个线程： sender1 线程、 sender2 线程和 receiver 线程，三个线程的功能描述如下：

    1. sender1 线程：运行函数 sender1() ，它创建一个消息队列，然后等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给 receiver 线程；可循环发送多个消息，直到用户输入 “exit” 为止，表示它不再发送消息，最后向 receiver 线程发送消息 “end1”，并且等待 receiver 的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，结束线程的运行。
    2. sender2 线程：运行函数sender2()，共享sender1创建的消息队列，等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给receiver线程可循环发送多个消息，直到用户输入“exit”为止，表示它不再发送消息，最后向receiver线程发送消息“end2”，并且等待receiver的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，结束线程的运行。
    3. receiver 线程：运行函数 receive()，它通过消息队列接收来自 sender1 和 sender2 两个线程的消息，将消息显示在终端屏幕上，当收到内容为 “end1” 的消息时，就向 sender1 发送一个应答消息 “over1” ；当收到内容为 “end2” 的消息时，就向 sender2 发送一个应答消息 “over2” ；消息接收完成后删除消息队列，结束线程的运行。选择合适的信号量机制实现三个线程之间的同步与互斥。

    此外，还要实现**多进程间同步、互斥通信**。

  - 编写程序 sender，它创建一个共享内存，然后等待用户通过终端输入一串字符，并将这串字符通过共享内存发送给 receiver；最后,它等待 receiver 的应答，收到应答消息后，将接收到的应答信息显示在终端屏幕上，删除共享内存，结束程序的运行。编写 receiver 程序，它通过共享内存接收来自 sender 的消息，将消息显示在终端屏幕上，然后再通过该共享内存向 sender 发送一个应答消息 “over”，结束程序的运行。选择合适的信号量机制实现两个进程对共享内存的互斥及同步使用。此外，还要实现**双向通信**





