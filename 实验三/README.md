# 实验三

该实验分为四个部分，分别对应四个文件夹



- shell —— 模拟 shell
  - shell.c —— 模拟 shell 的程序，入口文件
  - cmd1.c ——可以随便更改的命令文件，通过 shell 来调用
  - cmd2.c ——可以随便更改的命令文件，通过 shell 来调用
  - cmd3.c ——可以随便更改的命令文件，通过 shell 来调用
- pipe —— 管道通信
  - pipe.c —— 无名管道通信，实现三个字进程和父进程通信
  - read.c —— 有名管道通信，和 write 配合测试管道容量
  - write.c —— 有名管道通信，和 read 配合测试管道容量
- msg —— 消息队列
  - receive.c —— 接收者程序
  - sender1.c —— 发送者程序1
  - sender2.c —— 发送者程序2
  - msg.h —— 共用的变量声明和宏定义
- sharemy —— 共享内存
  - sender.c —— 程序一，因为既有接收线程又有发送线程，因此名字只是为了区分
  - receive.c —— 程序二，因为既有接收线程又有发送线程，因此名字只是为了区分
  - sharemy.h —— 共用的变量声明和宏定义以及初始化函数的定义



## 注意事项

### 模拟shell

这个实验简单没啥好说的

### 管道通信

pipe 文件为无名管道通信，单独使用

read 和 write 为有名管道通信，运行时会创建一个管道文件，两个程序需要都运行才有效果，单个运行时，只会阻塞

建议借鉴的同学修改写入的数据

```c++
sprintf(buf, "这是第 %d 次写入的数据", ++cnt);
```

### 消息队列

个人觉得最复杂的一个，三个程序都要运行，建议先运行 receive

信号量上由于消息队列本身就有同步机制，因此我去掉了所有的同步信号量，只保留了 `sender1_receive` 和 `sender2_receive` 来保证接收程序只有在确认两个发送程序接收到 over 后才会退出

消息队列的创建是通过 共同的 key 来生成的，而我没有指定共同的 key，是通过共同的 project ID 和固定的文件来生成 key 的，请确保 PATHNAME 指定的文件存在，是哪个文件都没有任何关系 project ID 也可以随便修改，不过只能在 [0,255]

```c++
#define PROJID 125
#define PATHNAME "./msg.h"
```

最后因为老师看过我这部分的代码，似乎觉得我的信号量设计的不太好，可能是想我们自己实现同步机制，而不是用消息队列本身的，因此建议参考生产者和消费者问题，增加一些同步信号量

代码中有很多输出的提示信息，是用来调试的，建议删除，还有部分注释是弃用的信号量，建议删除

### 共享内存

没什么东西，唯一需要注意的就是 key 的生成方式和消息队列一样，参考上一条
